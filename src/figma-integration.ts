import { ComponentSpec, ElementSpec, ElementProperties } from "./types";
import { hexToRgba, createEffect, clone, createDefaultFill, createDefaultStroke } from "./utils";

/**
 * Create Figma nodes from component specification
 * @param componentSpec Component specification generated by AI
 * @returns The parent frame containing all created nodes
 */
export async function createFigmaNodes(componentSpec: ComponentSpec) {
  const frame = figma.createFrame();
  frame.name = componentSpec.name;
  
  // Apply auto-layout
  frame.layoutMode = componentSpec.layout as "HORIZONTAL" | "VERTICAL" | "NONE";
  frame.primaryAxisSizingMode = "AUTO";
  frame.counterAxisSizingMode = "AUTO";
  frame.paddingLeft = 16;
  frame.paddingRight = 16;
  frame.paddingTop = 16;
  frame.paddingBottom = 16;
  frame.itemSpacing = 8;
  
  // Create child elements
  for (const element of componentSpec.elements) {
    const node = await createElement(element);
    if (node) {
      frame.appendChild(node);
    }
  }
  
  // Focus on the created frame
  figma.viewport.scrollAndZoomIntoView([frame]);
  return frame;
}

/**
 * Create individual Figma element based on specification
 * @param element Element specification
 * @returns Created Figma node
 */
async function createElement(element: ElementSpec): Promise<SceneNode | null> {
  switch(element.type.toLowerCase()) {
    case 'button': {
      return createButton(element);
    }
    
    case 'text': {
      return createText(element);
    }
    
    case 'rectangle': {
      return createRectangle(element);
    }
    
    case 'input': {
      return createInputField(element);
    }
    
    case 'icon': {
      return createIcon(element);
    }
    
    case 'image': {
      return createImagePlaceholder(element);
    }
    
    default:
      figma.notify(`⚠️ Unknown element type: ${element.type}`);
      return null;
  }
}

/**
 * Create a button element
 */
async function createButton(element: ElementSpec): Promise<SceneNode> {
  const button = figma.createFrame();
  button.name = element.name;
  
  // Apply button styles
  button.layoutMode = "HORIZONTAL";
  button.primaryAxisAlignItems = "CENTER";
  button.counterAxisAlignItems = "CENTER";
  button.paddingLeft = 16;
  button.paddingRight = 16;
  button.paddingTop = 8;
  button.paddingBottom = 8;
  
  // Apply properties
  if (element.properties) {
    if (element.properties.width) button.resize(element.properties.width, button.height);
    if (element.properties.height) button.resize(button.width, element.properties.height);
    if (element.properties.cornerRadius) button.cornerRadius = element.properties.cornerRadius;
    if (element.properties.fills && Array.isArray(element.properties.fills)) {
      const fill = element.properties.fills[0] as SolidPaint;
      if (fill?.type === "SOLID") {
        button.fills = [createDefaultFill(`#${Math.round(fill.color.r * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.g * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.b * 255).toString(16).padStart(2, '0')}`)];
      }
    }
  }
  
  // Create button text
  if (element.properties && element.properties.text) {
    const text = figma.createText();
    await loadFonts();
    text.characters = element.properties.text;
    
    if (element.properties.fontSize) text.fontSize = element.properties.fontSize;
    if (element.properties.textColor) {
      text.fills = [createDefaultFill(element.properties.textColor)];
    }
    
    button.appendChild(text);
  }
  
  return button;
}

/**
 * Create a text element
 */
async function createText(element: ElementSpec): Promise<SceneNode> {
  const text = figma.createText();
  text.name = element.name;
  
  await loadFonts();
  
  if (element.properties) {
    if (element.properties.text) text.characters = element.properties.text;
    if (element.properties.fontSize) text.fontSize = element.properties.fontSize;
    if (element.properties.textColor) {
      text.fills = [createDefaultFill(element.properties.textColor)];
    }
    if (element.properties.width) text.resize(element.properties.width, text.height);
    if (element.properties.fontWeight === "bold") {
      await figma.loadFontAsync({ family: "Inter", style: "Bold" });
      text.fontName = { family: "Inter", style: "Bold" };
    }
  }
  
  return text;
}

/**
 * Create a rectangle element
 */
function createRectangle(element: ElementSpec): SceneNode {
  const rect = figma.createRectangle();
  rect.name = element.name;
  
  if (element.properties) {
    if (element.properties.width) rect.resize(element.properties.width, rect.height);
    if (element.properties.height) rect.resize(rect.width, element.properties.height);
    if (element.properties.cornerRadius) rect.cornerRadius = element.properties.cornerRadius;
    if (element.properties.fills && Array.isArray(element.properties.fills)) {
      const fill = element.properties.fills[0] as SolidPaint;
      if (fill?.type === "SOLID") {
        rect.fills = [createDefaultFill(`#${Math.round(fill.color.r * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.g * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.b * 255).toString(16).padStart(2, '0')}`)];
      }
    }
  }
  
  return rect;
}

/**
 * Create an input field
 */
async function createInputField(element: ElementSpec): Promise<SceneNode> {
  const frame = figma.createFrame();
  frame.name = element.name;
  frame.layoutMode = "HORIZONTAL";
  frame.paddingLeft = 12;
  frame.paddingRight = 12;
  frame.paddingTop = 8;
  frame.paddingBottom = 8;
  
  // Style the input field
  frame.cornerRadius = element.properties?.cornerRadius || 4;
  frame.resize(element.properties?.width || 240, element.properties?.height || 40);
  
  // Create border
  frame.strokes = [{ type: 'SOLID', color: { r: 0.7, g: 0.7, b: 0.7 } }];
  frame.fills = [createDefaultFill("#FFFFFF")];
  
  // Create placeholder text
  if (element.properties?.placeholder) {
    const text = figma.createText();
    await loadFonts();
    text.characters = element.properties.placeholder;
    text.opacity = 0.5;
    text.fills = [createDefaultFill("#000000")];
    frame.appendChild(text);
  }
  
  return frame;
}

/**
 * Create a simple icon
 */
function createIcon(element: ElementSpec): SceneNode {
  const icon = figma.createFrame();
  icon.name = element.name;
  icon.resize(element.properties?.size || 24, element.properties?.size || 24);
  
  // Create a simple shape for the icon
  const shape = figma.createEllipse();
  shape.resize(icon.width, icon.height);
  
  if (element.properties?.fills && Array.isArray(element.properties.fills)) {
    const fill = element.properties.fills[0] as SolidPaint;
    if (fill?.type === "SOLID") {
      shape.fills = [createDefaultFill(`#${Math.round(fill.color.r * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.g * 255).toString(16).padStart(2, '0')}${Math.round(fill.color.b * 255).toString(16).padStart(2, '0')}`)];
    }
  } else {
    shape.fills = [createDefaultFill("#000000")];
  }
  
  icon.appendChild(shape);
  return icon;
}

/**
 * Create an image placeholder
 */
function createImagePlaceholder(element: ElementSpec): SceneNode {
  const frame = figma.createFrame();
  frame.name = element.name;
  
  // Set dimensions
  frame.resize(element.properties?.width || 200, element.properties?.height || 150);
  
  // Create background
  frame.fills = [{ type: 'SOLID', color: { r: 0.9, g: 0.9, b: 0.9 } }];
  
  // Create placeholder rectangle
  const rect = figma.createRectangle();
  rect.resize(frame.width, frame.height);
  rect.fills = [{ type: 'SOLID', color: { r: 0.9, g: 0.9, b: 0.9 } }];
  
  frame.appendChild(rect);
  return frame;
}

/**
 * Helper function to load fonts
 */
export async function loadFonts() {
  await Promise.all([
    figma.loadFontAsync({ family: "Inter", style: "Regular" }),
    figma.loadFontAsync({ family: "Inter", style: "Bold" })
  ]);
}

/**
 * Convert RGB color to hex string
 */
function rgbToHex(color: RGB): string {
  const r = Math.round(color.r * 255);
  const g = Math.round(color.g * 255);
  const b = Math.round(color.b * 255);
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

/**
 * Get color from paint style
 */
function getColorFromPaint(paint: Paint | null | undefined): string {
  if (paint && paint.type === "SOLID") {
    return rgbToHex(paint.color);
  }
  return "#000000";
}

/**
 * Get the first paint from fills
 */
function isValidFills(fills: any): fills is ReadonlyArray<Paint> | Paint[] {
  return Array.isArray(fills) && fills.length > 0 && fills[0].type === "SOLID";
}

function getFirstPaint(fills: ReadonlyArray<Paint> | Paint[] | undefined | null): Paint | null {
  if (!fills || !isValidFills(fills)) return null;
  return fills[0];
}

/**
 * Convert a Paint array to a hex color string
 */
function getFillColor(fills: ReadonlyArray<Paint> | Paint[] | undefined | null): string {
  const paint = getFirstPaint(fills);
  if (paint && paint.type === "SOLID") {
    return `#${Math.round(paint.color.r * 255).toString(16).padStart(2, '0')}${Math.round(paint.color.g * 255).toString(16).padStart(2, '0')}${Math.round(paint.color.b * 255).toString(16).padStart(2, '0')}`;
  }
  return "#000000";
}

/**
 * Extract component specification from existing Figma node
 */
export async function getComponentSpec(node: BaseNode): Promise<ComponentSpec> {
  if (node.type !== "FRAME" && node.type !== "COMPONENT") {
    throw new Error("Selected node must be a frame or component");
  }

  const frame = node as FrameNode;
  const spec: ComponentSpec = {
    name: frame.name,
    layout: frame.layoutMode as ComponentSpec["layout"],
    elements: []
  };

  // Extract specifications from child nodes
  for (const child of frame.children) {
    const elementSpec = await extractElementSpec(child);
    if (elementSpec) {
      spec.elements.push(elementSpec);
    }
  }

  return spec;
}

/**
 * Extract element specification from a Figma node
 */
async function extractElementSpec(node: SceneNode): Promise<ElementSpec | null> {
  const baseSpec: ElementSpec = {
    name: node.name,
    type: "rectangle", // Default type, will be overridden if needed
    properties: {}
  };

  switch (node.type) {    case "FRAME": {
      const frame = node as FrameNode;
      if (frame.name.toLowerCase().includes("button")) {
        const textChild = frame.findChild(n => n.type === "TEXT") as TextNode | null;
        const frameFills = Array.isArray(frame.fills) ? frame.fills : [];
        const textFills = textChild && Array.isArray(textChild.fills) ? textChild.fills : [];
        
        baseSpec.type = "button";
        baseSpec.properties = {
          text: textChild?.characters || "",
          width: frame.width,
          height: frame.height,
          cornerRadius: typeof frame.cornerRadius === "number" ? frame.cornerRadius : 0,
          fills: frameFills,
          textColor: getFillColor(textFills),
          fontSize: typeof textChild?.fontSize === "number" ? textChild.fontSize : 16
        };
        return baseSpec;
      }
      break;
    }

    case "TEXT": {
      const text = node as TextNode;
      const textFills = Array.isArray(text.fills) ? text.fills : [];
      baseSpec.type = "text";
      baseSpec.properties = {
        text: text.characters,
        fontSize: typeof text.fontSize === "number" ? text.fontSize : 16,
        textColor: getFillColor(textFills),
        width: text.width,
        fontWeight: text.fontName && typeof text.fontName === "object" && "style" in text.fontName 
          ? text.fontName.style.toLowerCase().includes("bold") ? "bold" : "regular"
          : "regular"
      };
      return baseSpec;
    }

    case "RECTANGLE": {
      const rect = node as RectangleNode;
      const rectFills = Array.isArray(rect.fills) ? rect.fills : [];
      baseSpec.type = "rectangle";
      baseSpec.properties = {
        width: rect.width,
        height: rect.height,
        cornerRadius: typeof rect.cornerRadius === "number" ? rect.cornerRadius : 0,
        fills: rectFills
      };
      return baseSpec;
    }
  }

  return null;
}

/**
 * Update existing Figma nodes with new component specification
 */
export async function updateFigmaNodes(frame: FrameNode, componentSpec: ComponentSpec): Promise<void> {
  // Update frame properties
  frame.name = componentSpec.name;
  frame.layoutMode = componentSpec.layout;
  frame.primaryAxisSizingMode = "AUTO";
  frame.counterAxisSizingMode = "AUTO";
  
  // Remove existing children
  for (const child of [...frame.children]) {
    child.remove();
  }
  
  // Create new children from specification
  for (const element of componentSpec.elements) {
    const node = await createElement(element);
    if (node) {
      frame.appendChild(node);
    }
  }
  
  // Update frame appearance
  frame.paddingLeft = 16;
  frame.paddingRight = 16;
  frame.paddingTop = 16;
  frame.paddingBottom = 16;
  frame.itemSpacing = 8;
  
  // Focus on the updated frame
  figma.viewport.scrollAndZoomIntoView([frame]);
}

// Helper function to apply styles based on breakpoint
function applyResponsiveProperties(node: BaseNode & { [key: string]: any }, baseProps: ElementProperties, responsiveProps: ElementProperties | null) {
  const props = responsiveProps ? { ...baseProps, ...responsiveProps } : baseProps;

  Object.entries(props).forEach(([key, value]) => {
    if (node[key] !== undefined) {
      node[key] = value;
    }
  });
}

export async function createFigmaComponent(spec: ComponentSpec): Promise<FrameNode> {
  // Create main frame
  const frame = figma.createFrame();
  frame.name = spec.name;
  frame.layoutMode = spec.layout;
  frame.primaryAxisSizingMode = "AUTO";
  frame.counterAxisSizingMode = "AUTO";
  frame.paddingLeft = frame.paddingRight = 16;
  frame.paddingTop = frame.paddingBottom = 16;
  frame.itemSpacing = 8;

  // Apply background if specified
  if (spec.background) {
    const bg = figma.createRectangle();
    bg.name = "Background";
    bg.fills = [createDefaultFill(spec.background.properties.fill)];
    
    if (spec.background.properties.cornerRadius) {
      bg.cornerRadius = spec.background.properties.cornerRadius;
    }
    
    if (spec.background.properties.effect) {
      bg.effects = [createEffect(spec.background.properties.effect)];
    }
    
    frame.appendChild(bg);
    bg.layoutPositioning = "ABSOLUTE";
    bg.resize(frame.width, frame.height);
  }

  // Create elements
  for (const element of spec.elements) {
    const node = await createElementNode(element);
    if (node) {
      frame.appendChild(node);
      if ("layoutAlign" in node) {
        node.layoutAlign = "STRETCH";
      }
      
      // Apply base properties
      applyResponsiveProperties(node, element.properties, null);
      
      // Store responsive variants in metadata
      if (element.responsive) {
        node.setPluginData("responsive", JSON.stringify(element.responsive));
      }
    }
  }

  return frame;
}

async function createElementNode(element: ElementSpec): Promise<SceneNode | null> {
  switch (element.type) {
    case "button": {
      const button = figma.createFrame();
      button.name = element.name;
      button.layoutMode = "HORIZONTAL";
      button.primaryAxisSizingMode = "AUTO";
      button.counterAxisSizingMode = "AUTO";
      const fill = element.properties.fills?.[0] as SolidPaint;
      button.fills = [createDefaultFill(fill?.color ? `#${fill.color.r.toString(16)}${fill.color.g.toString(16)}${fill.color.b.toString(16)}` : "#FFFFFF")];
      button.cornerRadius = element.properties.cornerRadius ?? 4;
      return button;
    }
    case "text": {
      const text = figma.createText();
      text.name = element.name;
      if (element.properties.fontName) {
        await figma.loadFontAsync(element.properties.fontName);
        text.fontName = element.properties.fontName;
      } else {
        await figma.loadFontAsync({ family: "Inter", style: "Regular" });
        text.fontName = { family: "Inter", style: "Regular" };
      }
      if (element.properties.characters) {
        text.characters = element.properties.characters;
      }
      if (element.properties.fontSize) {
        text.fontSize = element.properties.fontSize;
      }
      return text;
    }
    case "rectangle": {
      const rect = figma.createRectangle();
      rect.name = element.name;
      if (element.properties.fills?.length) {
        rect.fills = element.properties.fills.map(fill => 
          createDefaultFill((fill as SolidPaint).color.toString())
        );
      }
      if (element.properties.cornerRadius) {
        rect.cornerRadius = element.properties.cornerRadius;
      }
      return rect;
    }
    case "input": {
      const input = figma.createFrame();
      input.name = element.name;
      input.layoutMode = "HORIZONTAL";
      input.fills = [createDefaultFill("#FFFFFF")];
      input.strokes = [createDefaultStroke("#00000020", 1)];
      input.cornerRadius = 4;
      input.paddingLeft = input.paddingRight = 8;
      input.paddingTop = input.paddingBottom = 8;
      return input;
    }
    case "icon": {
      const icon = figma.createFrame();
      icon.name = element.name;
      icon.layoutMode = "NONE";
      icon.fills = [createDefaultFill("#000000")];
      icon.resize(24, 24);
      return icon;
    }
    case "image": {
      const image = figma.createFrame();
      image.name = element.name;
      image.layoutMode = "NONE";
      image.fills = [createDefaultFill("#F0F0F0")];
      image.resize(100, 100);
      return image;
    }
    default:
      console.warn(`Unsupported element type: ${element.type}`);
      return null;
  }
}

export async function updateFigmaComponent(frame: FrameNode, componentSpec: ComponentSpec): Promise<void> {
  frame.name = componentSpec.name;
  frame.layoutMode = componentSpec.layout;
  
  // Update or create background
  if (componentSpec.background) {
    let bg = frame.findChild(n => n.name === "Background") as RectangleNode | null;
    if (!bg) {
      bg = figma.createRectangle();
      bg.name = "Background";
      frame.appendChild(bg);
      bg.layoutPositioning = "ABSOLUTE";
    }
    
    bg.fills = [createDefaultFill(componentSpec.background.properties.fill)];
    if (componentSpec.background.properties.cornerRadius) {
      bg.cornerRadius = componentSpec.background.properties.cornerRadius;
    }
    if (componentSpec.background.properties.effect) {
      bg.effects = [createEffect(componentSpec.background.properties.effect)];
    }
  }

  // Update elements
  const elementsToRemove = new Set(frame.children);
  for (const elementSpec of componentSpec.elements) {
    let node = frame.findChild(n => n.name === elementSpec.name) as SceneNode;
    if (!node) {
      const newNode = await createElementNode(elementSpec);
      if (newNode) {
        frame.appendChild(newNode);
      }
    } else {
      elementsToRemove.delete(node);
      applyResponsiveProperties(node, elementSpec.properties, null);
      if (elementSpec.responsive) {
        node.setPluginData("responsive", JSON.stringify(elementSpec.responsive));
      }
    }
  }
  
  // Remove any elements that are no longer in the spec
  elementsToRemove.forEach(node => {
    if (node.name !== "Background") {
      node.remove();
    }
  });
}

// Helper function to update component for a specific breakpoint
export async function updateComponentForBreakpoint(node: SceneNode, breakpoint: "mobile" | "tablet" | "desktop") {
  const responsiveData = node.getPluginData("responsive");
  if (responsiveData) {
    const responsive = JSON.parse(responsiveData);
    if (responsive[breakpoint]) {
      applyResponsiveProperties(node, {}, responsive[breakpoint]);
    }
  }
  
  if ("children" in node) {
    for (const child of node.children) {
      await updateComponentForBreakpoint(child, breakpoint);
    }
  }
}